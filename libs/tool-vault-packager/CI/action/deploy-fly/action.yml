name: 'Deploy ToolVault to Fly.io'
description: 'Deploy tool-vault-packager to Fly.io with Docker'
inputs:
  app_name:
    description: 'Fly.io app name'
    required: true
  config_file:
    description: 'Fly.io config file to use (fly-production.toml or fly-template.toml)'
    required: true
  build_args:
    description: 'Docker build args (multiline string)'
    required: true
  github_sha:
    description: 'GitHub SHA for the deployment'
    required: true
  fly_api_token:
    description: 'Fly.io API token'
    required: true

outputs:
  deployment_status:
    description: 'Deployment status (success or partial)'
    value: ${{ steps.deploy.outputs.deployment_status }}
  app_url:
    description: 'URL of the deployed app'
    value: ${{ steps.config.outputs.app_url }}

runs:
  using: 'composite'
  steps:
    - name: Setup Fly CLI
      uses: superfly/flyctl-actions/setup-flyctl@master
    
    - name: Configure deployment
      id: config
      shell: bash
      working-directory: libs/tool-vault-packager
      run: |
        APP_NAME="${{ inputs.app_name }}"
        APP_URL="https://${APP_NAME}.fly.dev"
        
        echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT
        
        # Handle different config file patterns
        if [[ "${{ inputs.config_file }}" == "fly-template.toml" ]]; then
          # For PR deployments - substitute placeholders
          sed "s/PR_APP_NAME_PLACEHOLDER/${APP_NAME}/g; s/PR_NUMBER_PLACEHOLDER/${{ github.event.number || 'unknown' }}/g" \
            fly-template.toml > fly.toml
          echo "Generated fly.toml from template for app: ${APP_NAME}"
        else
          # For production deployments - copy config file
          cp "${{ inputs.config_file }}" fly.toml
          echo "Using config file: ${{ inputs.config_file }} for app: ${APP_NAME}"
        fi
        
        echo "Final deployment configuration:"
        cat fly.toml

    - name: Stage shared-types for Docker build
      shell: bash
      working-directory: .
      run: |
        set -euo pipefail

        SRC_DIR="libs/shared-types"
        DEST_DIR="libs/tool-vault-packager/shared-types"

        if [ ! -d "${SRC_DIR}" ]; then
          echo "Shared-types directory not found at ${SRC_DIR}." >&2
          echo "Run the shared-types build before deploying." >&2
          exit 1
        fi

        # Copy complete shared-types package for Docker build context
        echo "Copying shared-types package for Docker build..."
        rm -rf "${DEST_DIR}"
        mkdir -p "${DEST_DIR}"

        # Copy package files needed for TypeScript builds
        cp "${SRC_DIR}/package.json" "${DEST_DIR}/"

        # Copy built TypeScript artifacts
        if [ -d "${SRC_DIR}/dist" ]; then
          cp -r "${SRC_DIR}/dist" "${DEST_DIR}/"
        fi

        if [ -d "${SRC_DIR}/src" ]; then
          cp -r "${SRC_DIR}/src" "${DEST_DIR}/"
        fi

        if [ -d "${SRC_DIR}/derived" ]; then
          cp -r "${SRC_DIR}/derived" "${DEST_DIR}/"
        fi

        # Verify Python wheel exists
        PYTHON_DIST="${DEST_DIR}/dist/python"
        if [ ! -d "${PYTHON_DIST}" ]; then
          echo "Python dist directory not found after copy." >&2
          exit 1
        fi

        WHEEL_PATH=$(find "${PYTHON_DIST}" -maxdepth 1 -name 'debrief_types-*.whl' -print -quit)
        if [ -z "${WHEEL_PATH}" ]; then
          echo "No debrief_types wheel found after copy." >&2
          exit 1
        fi

        echo "Staged shared-types package with wheel: $(basename "${WHEEL_PATH}")"
    
    - name: Deploy to Fly.io
      id: deploy
      shell: bash
      working-directory: libs/tool-vault-packager
      env:
        FLY_API_TOKEN: ${{ inputs.fly_api_token }}
      run: |
        APP_NAME="${{ inputs.app_name }}"
        
        # Check if app exists, create if it doesn't
        if ! flyctl apps list | grep -q "^${APP_NAME}"; then
          echo "Creating new app: ${APP_NAME}"
          flyctl apps create "${APP_NAME}" --org personal
        else
          echo "App ${APP_NAME} already exists, updating..."
        fi
        
        # Prepare Fly logs capability detection
        LOGS_HELP="$(flyctl logs --help 2>&1 || true)"
        LOG_LIMIT_FLAG=""
        if echo "${LOGS_HELP}" | grep -q -- '--limit'; then
          LOG_LIMIT_FLAG="--limit"
        elif echo "${LOGS_HELP}" | grep -q -- '--max'; then
          LOG_LIMIT_FLAG="--max"
        fi

        fetch_logs() {
          local limit="${1:-}"
          shift || true

          local args=(--no-tail)
          if [ -n "${limit}" ] && [ -n "${LOG_LIMIT_FLAG}" ]; then
            args=("${LOG_LIMIT_FLAG}" "${limit}" "${args[@]}")
          fi

          flyctl logs --app "${APP_NAME}" "${args[@]}" "$@" || true
        }

        # Prepare build args
        BUILD_ARGS=""
        while IFS= read -r line; do
          if [[ -n "$line" && "$line" != " "* ]]; then
            BUILD_ARGS="$BUILD_ARGS --build-arg $line"
          fi
        done <<< "${{ inputs.build_args }}"
        
        # Deploy the application
        echo "Deploying to ${APP_NAME}..."
        echo "Starting deployment at $(date)"
        echo "Build args: $BUILD_ARGS"
        
        # Deploy with timeout protection (FastAPI specific settings)
        timeout 600 flyctl deploy --app "${APP_NAME}" --dockerfile ./Dockerfile \
          $BUILD_ARGS \
          --wait-timeout 300 \
          --strategy immediate \
          --verbose || {
            echo "Deployment timed out or failed after 10 minutes"
            echo "Checking app status..."
            flyctl status --app "${APP_NAME}" || true
            exit 1
          }
        
        echo "Deployment completed at $(date)"
        
        # Check deployment status
        echo "Checking deployment status..."
        flyctl status --app "${APP_NAME}"
        
        # Check recent logs for any startup issues
        echo "Checking recent logs..."
        fetch_logs 50
        
        # Give the app time to fully start
        echo "Waiting for app to fully initialize..."
        sleep 45
        
        # Verify the app is responding (FastAPI health check on port 5000)
        APP_URL="https://${APP_NAME}.fly.dev"
        echo "Testing app availability at ${APP_URL}..."
        
        # Test FastAPI endpoints
        if timeout 120 bash -c "until curl -f -s -m 30 ${APP_URL}/health > /dev/null; do echo 'Waiting for health endpoint response...'; sleep 10; done"; then
          echo "✅ App health endpoint is responding at ${APP_URL}/health"
          
          # Also test the root endpoint
          if curl -f -s -m 30 "${APP_URL}/" > /dev/null; then
            echo "✅ App root endpoint is responding at ${APP_URL}/"
            echo "deployment_status=success" >> $GITHUB_OUTPUT
          else
            echo "⚠️  Health endpoint works but root endpoint not responding"
            echo "deployment_status=partial" >> $GITHUB_OUTPUT
          fi
        else
          echo "⚠️  App deployed but not responding at ${APP_URL}"
          echo "Checking final app status and logs..."
          flyctl status --app "${APP_NAME}" || true
          fetch_logs 20
          echo "deployment_status=partial" >> $GITHUB_OUTPUT
        fi
