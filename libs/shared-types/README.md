# @debrief/shared-types

Shared types for Debrief ecosystem with constrained GeoJSON FeatureCollections for maritime analysis.

## Overview

This package provides:

- **JSON Schema definitions** for Debrief feature types (Track, Point, Annotation, FeatureCollection)
- **Generated TypeScript interfaces** from schemas using json-schema-to-typescript with proper discriminated unions
- **Generated Python models** from schemas using QuickType  
- **Manual validators** with cross-field validation logic for both TypeScript and Python
- **Comprehensive test suites** to ensure consistency across languages

## Features

### Build-Based Approach

**Important**: The `derived/` directory contains generated files and is excluded from version control via `.gitignore`. Types are generated by the build process using a hybrid approach for optimal type safety:

```
JSON Schema (master) → json-schema-to-typescript → TypeScript Types (derived/typescript/)
JSON Schema (master) → QuickType → Python Types (derived/python/)
```

**TypeScript Discriminated Unions**: TypeScript generation uses json-schema-to-typescript which properly handles oneOf schemas to create discriminated union types with literal discriminator properties (e.g., `featureType: "track"` instead of `featureType: string`), enabling automatic type narrowing.

```bash
npm run build        # Generate all types and prepare distribution
npm run build:ts     # Generate TypeScript types only
npm run build:python # Generate Python types only
```

### Schema-Driven Development

All types are derived from JSON Schema definitions in `schema/`:

- `track.schema.json` - LineString/MultiLineString features with optional timestamps
- `point.schema.json` - Point features with time properties
- `annotation.schema.json` - Multi-geometry annotation features
- `featurecollection.schema.json` - Top-level collection schema

### Cross-Field Validation

Manual validators provide critical validation logic not covered by JSON Schema:

- **Timestamps validation**: Array length must match coordinate points count
- **Time properties validation**: Point features support either single time OR time range
- **Geographic coordinate validation**: Coordinates within valid ranges
- **Annotation type validation**: Color formats, annotation types, etc.

## Usage

### TypeScript

**Note**: This is a source package. Import directly from the directories you need:

```typescript
// Import generated types directly
import { TrackFeature } from '@debrief/shared-types/derived/typescript/track';
import { PointFeature } from '@debrief/shared-types/derived/typescript/point';

// Import validators directly  
import { validateTrackFeature, validateTimestampsLength } from '@debrief/shared-types/validators/typescript/track-validator';

// Use generated types
const track: TrackFeature = {
  type: 'Feature',
  id: 'track-001',
  geometry: {
    type: 'LineString',
    coordinates: [[-1.0, 51.0], [-0.9, 51.1]]
  },
  properties: {
    timestamps: ['2024-01-01T10:00:00Z', '2024-01-01T10:01:00Z'],
    name: 'Sample Track'
  }
};

// Validate with cross-field rules
if (validateTrackFeature(track) && validateTimestampsLength(track)) {
  console.log('Valid track!');
}
```

### TypeScript Discriminated Union Example

```typescript
import { DebriefFeatureCollection, DebriefFeature } from '@debrief/shared-types';

function processFeature(feature: DebriefFeature) {
  // TypeScript automatically narrows the type based on discriminator
  if (feature.properties.featureType === 'track') {
    // feature is now typed as DebriefTrackFeature
    console.log(`Track with ${feature.properties.timestamps?.length} timestamps`);
  } else if (feature.properties.featureType === 'point') {
    // feature is now typed as DebriefPointFeature  
    console.log(`Point at time: ${feature.properties.time}`);
  } else if (feature.properties.featureType === 'annotation') {
    // feature is now typed as DebriefAnnotationFeature
    console.log(`Annotation: ${feature.properties.text}`);
  }
  // No manual type guards needed!
}

const collection: DebriefFeatureCollection = {
  type: 'FeatureCollection',
  features: [/* ... */]
};

collection.features.forEach(processFeature);
```

### Python

```python
from debrief_shared_types.validators.python import (
    validate_track_feature,
    validate_timestamps_length
)

# Validate track data
track_data = {
    'type': 'Feature',
    'id': 'track-001',
    'geometry': {
        'type': 'LineString',
        'coordinates': [[-1.0, 51.0], [-0.9, 51.1]]
    },
    'properties': {
        'timestamps': ['2024-01-01T10:00:00Z', '2024-01-01T10:01:00Z'],
        'name': 'Sample Track'
    }
}

if validate_track_feature(track_data) and validate_timestamps_length(track_data):
    print('Valid track!')
```

## Development

### Building

```bash
npm install              # Install dependencies
npm run build           # Generate types and prepare distribution
npm run test            # Run all tests
```

### Testing

The package includes comprehensive test suites:

```bash
npm run test:generated  # Test that generated files exist and are valid
npm run test:validators # Test that validators work correctly  
npm run test:schemas    # Test JSON Schema validation
```

### Schema Validation

All schemas are validated using AJV and tested with sample data:

```bash
npm run test:schemas    # Validate schemas and test data
```

## Package Structure

```
libs/shared-types/
├── schema/                 # JSON Schema definitions (source of truth)
├── templates/             # Manual templates for complex types (.ts.txt files)
├── derived/               # Generated types (not committed)
│   ├── typescript/        # Generated TS interfaces
│   └── python/           # Generated Python models  
├── validators/           # Manual validators (committed)
│   ├── typescript/       # TS validator functions
│   └── python/          # Python validator functions
├── tests/               # Test suites
├── src/                 # Package entry points
└── dist/               # Distribution build output
```

## Key Design Principles

1. **Schema-First**: JSON Schemas are the source of truth
2. **Build-Generated Types**: Types generated by build process, not manually maintained
3. **Template Files**: Manual templates (`.ts.txt`) used for complex types to avoid compiler warnings
4. **Manual Validators**: Validation logic manually written and maintained
5. **Cross-Language Consistency**: Identical validation behavior in TS and Python
6. **Comprehensive Testing**: Tests ensure generated files exist and validators work

## Version Compatibility

- **Node.js**: >=16.0.0
- **Python**: >=3.8
- **TypeScript**: >=4.0

## License

MIT

## Contributing

1. Modify JSON schemas in `schema/` directory
2. Run `npm run build` to regenerate types
3. Update validators if needed (manual)
4. Run `npm run test` to ensure everything works
5. Submit PR

The build-based approach ensures consistency and reduces maintenance overhead while allowing validators to mature over time.