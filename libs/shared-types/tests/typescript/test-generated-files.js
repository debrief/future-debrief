#!/usr/bin/env node

/**
 * Test that verifies TypeScript files are generated correctly by the build process
 */

const fs = require('fs');
const path = require('path');

const DERIVED_DIR = path.join(__dirname, '..', '..', 'derived', 'typescript');

const EXPECTED_FILES = [
  'track.ts',
  'point.ts', 
  'annotation.ts',
  'featurecollection.ts'
];

const EXPECTED_EXPORTS = {
  'track.ts': ['DebriefTrackFeature'],
  'point.ts': ['DebriefPointFeature'], 
  'annotation.ts': ['DebriefAnnotationFeature'],
  'featurecollection.ts': ['DebriefFeatureCollection', 'DebriefFeature', 'DebriefTrackFeature', 'DebriefPointFeature', 'DebriefAnnotationFeature']
};

function testFileExists(filename) {
  const filePath = path.join(DERIVED_DIR, filename);
  if (!fs.existsSync(filePath)) {
    throw new Error(`Generated file missing: ${filename}`);
  }
  console.log(`âœ“ File exists: ${filename}`);
  return filePath;
}

function testFileContent(filename, filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  
  if (content.length === 0) {
    throw new Error(`Generated file is empty: ${filename}`);
  }
  
  // Check for expected exports
  const expectedExports = EXPECTED_EXPORTS[filename] || [];
  for (const exportName of expectedExports) {
    if (!content.includes(`export interface ${exportName}`) && 
        !content.includes(`export class ${exportName}`) &&
        !content.includes(`export type ${exportName}`) &&
        !content.includes(`export { ${exportName} }`)) {
      throw new Error(`Missing expected export '${exportName}' in ${filename}`);
    }
  }
  
  // Check for json-schema-to-typescript signature or re-export comment
  if (!content.includes('This file was automatically generated by json-schema-to-typescript') &&
      !content.includes('Re-export from featurecollection to avoid duplication')) {
    throw new Error(`File ${filename} doesn't appear to be generated by json-schema-to-typescript or be a valid re-export`);
  }
  
  console.log(`âœ“ File content valid: ${filename}`);
}

function testTypeScriptSyntax(filename, filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  
  // Basic TypeScript syntax checks
  const basicChecks = [
    /export\s+(interface|class|enum)\s+\w+|export\s*\{[^}]+\}|export\s+type\s+\w+/,  // Has exports (interface/class/enum or re-export or type)
  ];
  
  // Only require type annotations for files that aren't simple re-exports
  if (!content.includes('Re-export from featurecollection')) {
    basicChecks.push(/:\s*\w+/);  // Has type annotations
  }
  
  for (const check of basicChecks) {
    if (!check.test(content)) {
      throw new Error(`File ${filename} appears to have invalid TypeScript syntax`);
    }
  }
  
  console.log(`âœ“ TypeScript syntax valid: ${filename}`);
}

function runTests() {
  console.log('Testing TypeScript generated files...\n');
  
  let passedTests = 0;
  let failedTests = 0;
  
  for (const filename of EXPECTED_FILES) {
    try {
      const filePath = testFileExists(filename);
      testFileContent(filename, filePath);
      testTypeScriptSyntax(filename, filePath);
      passedTests++;
    } catch (error) {
      console.error(`âœ— ${error.message}`);
      failedTests++;
    }
  }
  
  console.log(`\nTest Results:`);
  console.log(`âœ“ Passed: ${passedTests}`);
  console.log(`âœ— Failed: ${failedTests}`);
  
  if (failedTests > 0) {
    console.error('\nSome tests failed. Run "npm run build" to regenerate files.');
    process.exit(1);
  }
  
  console.log('\nðŸŽ‰ All TypeScript generated file tests passed!');
}

// Only run if called directly
if (require.main === module) {
  runTests();
}

module.exports = { runTests };